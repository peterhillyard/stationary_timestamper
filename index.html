<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Image Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .main-content {
            display: flex;
            gap: 20px;
        }

        .viewer-section {
            flex: 1;
        }

        .dots-section {
            width: 300px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 15px;
            max-height: 600px;
            overflow-y: auto;
        }

        .dots-section h3 {
            margin: 0 0 15px 0;
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 5px;
        }

        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .file-input {
            margin-bottom: 10px;
        }

        .info {
            font-size: 14px;
            color: #666;
            margin-top: 10px;
        }

        .viewer-container {
            width: 100%;
            height: 600px;
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            background-color: #fff;
            cursor: grab;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        .viewer-container:active {
            cursor: grabbing;
        }

        .viewer-container.no-image {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #placeholder {
            display: block;
            text-align: center;
            color: #999;
            font-size: 18px;
        }

        #imageCanvas {
            display: none;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .zoom-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
        }

        .reset-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }

        .reset-btn:hover {
            background-color: #0056b3;
        }

        .clear-dots-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }

        .clear-dots-btn:hover {
            background-color: #c82333;
        }

        .save-btn {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }

        .save-btn:hover {
            background-color: #218838;
        }

        .timestamp-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }

        .timestamp-btn {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }

        .timestamp-btn:hover {
            background-color: #218838;
        }

        .timestamp-btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .timestamp-btn:disabled:hover {
            background-color: #6c757d;
        }

        .timestamp-btn.end {
            background-color: #dc3545;
        }

        .timestamp-btn.end:hover {
            background-color: #c82333;
        }

        .timestamp-btn.clear {
            background-color: #ffc107;
            color: #000;
        }

        .timestamp-btn.clear:hover {
            background-color: #e0a800;
        }

        .timestamp-display {
            margin-top: 10px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
        }

        .timestamp-display div {
            margin: 5px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .timestamp-label {
            font-weight: bold;
            color: #333;
            min-width: 40px;
        }

        .timestamp-input {
            flex: 1;
            padding: 5px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #007bff;
        }

        .timestamp-input:disabled {
            background-color: #f8f9fa;
            color: #999;
        }

        .ble-ids-section {
            margin-top: 10px;
        }

        .ble-ids-label {
            font-weight: bold;
            color: #333;
            display: block;
            margin-bottom: 5px;
        }

        .ble-ids-input {
            width: 100%;
            padding: 5px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .dot-item {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            position: relative;
        }

        .dot-item:hover {
            background-color: #e9ecef;
        }

        .dot-item.highlighted {
            background-color: #fff3cd;
            border-color: #ffc107;
            box-shadow: 0 0 8px rgba(255, 193, 7, 0.5);
        }

        .dot-index {
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }

        .dot-coordinates {
            color: #333;
            margin-bottom: 8px;
        }

        .dot-timestamp {
            color: #666;
            font-size: 10px;
            margin-bottom: 8px;
        }

        .dot-id-input {
            width: 100%;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .dot-id-input.valid {
            border-color: #28a745;
            background-color: #d4edda;
        }

        .dot-id-input.invalid {
            border-color: #dc3545;
            background-color: #f8d7da;
        }

        .dot-delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dot-delete-btn:hover {
            background: #c82333;
        }

        .no-dots-message {
            color: #999;
            font-style: italic;
            font-size: 14px;
        }

        .desktop-controls {
            display: inline;
        }

        .mobile-controls {
            display: none;
        }

        /* Mobile-specific improvements */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                max-width: 100%;
            }

            .controls {
                padding: 10px;
            }

            .main-content {
                flex-direction: column;
            }

            .dots-section {
                width: 100%;
                max-height: 300px;
                order: 2;
            }

            .viewer-section {
                order: 1;
            }

            .viewer-container {
                height: 400px;
            }

            .desktop-controls {
                display: none;
            }

            .mobile-controls {
                display: inline !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Image Viewer</h1>
        
        <div class="controls">
            <div class="file-input">
                <label for="imageInput">Select an image:</label>
                <input type="file" id="imageInput" accept="image/*">
                <button class="reset-btn" id="resetBtn">Reset View</button>
                <button class="clear-dots-btn" id="clearDotsBtn">Clear All Dots</button>
                <button class="save-btn" id="saveBtn">Save</button>
            </div>
            <div class="info">
                <strong>Controls:</strong> 
                <span class="desktop-controls">Left-click and drag to pan • Mouse wheel to zoom • Right-click on image to place dots • Reset button to fit image to view</span>
                <span class="mobile-controls">Single finger drag to pan • Pinch to zoom • Tap on image to place dots • Reset button to fit image to view</span>
            </div>
            <div class="timestamp-section">
                <button class="timestamp-btn" id="startBtn">Set Start Time</button>
                <button class="timestamp-btn end" id="endBtn" disabled>Set End Time</button>
                <button class="timestamp-btn clear" id="clearBtn">Clear</button>
                <div class="timestamp-display">
                    <div>
                        <span class="timestamp-label">Start:</span>
                        <input type="text" class="timestamp-input" id="startTime" placeholder="Not set" disabled>
                    </div>
                    <div>
                        <span class="timestamp-label">End:</span>
                        <input type="text" class="timestamp-input" id="endTime" placeholder="Not set" disabled>
                    </div>
                </div>
                <div class="ble-ids-section">
                    <label class="ble-ids-label" for="bleIdsInput">Allowed BLE TX IDs (comma-separated):</label>
                    <input type="text" class="ble-ids-input" id="bleIdsInput" placeholder="e.g., ID001, ID002, ID003">
                </div>
                <div class="ble-ids-section" style="margin-top: 10px;">
                    <label class="ble-ids-label" for="floorNumberInput">Floor Number:</label>
                    <input type="number" class="ble-ids-input" id="floorNumberInput" placeholder="Enter floor number...">
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="viewer-section">
                <div class="viewer-container no-image" id="viewerContainer">
                    <canvas id="imageCanvas"></canvas>
                    <div class="zoom-info" id="zoomInfo">Zoom: 100%</div>
                    <div id="placeholder">Select an image to start viewing</div>
                </div>
            </div>

            <div class="dots-section">
                <h3>Dots</h3>
                <div id="dotsList">
                    <p class="no-dots-message">Right-click on the image to place dots</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        class ImageViewer {
            constructor() {
                this.canvas = document.getElementById('imageCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.container = document.getElementById('viewerContainer');
                this.zoomInfo = document.getElementById('zoomInfo');
                this.placeholder = document.getElementById('placeholder');
                
                this.image = null;
                this.scale = 1;
                this.panX = 0;
                this.panY = 0;
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                this.minScale = 0.1;
                this.maxScale = 10;
                this.fitScale = 1; // Track the initial fit-to-view scale
                
                // Touch handling properties
                this.touches = [];
                this.lastTouchDistance = 0;
                this.isTouching = false;
                this.touchStartTime = 0;
                this.touchStartPos = null;
                this.hasPerformedGesture = false;
                
                // Timestamp properties
                this.startDateTime = null;
                this.endDateTime = null;
                
                // BLE TX IDs
                this.allowedBleIds = [];
                
                // Floor number
                this.floorNumber = null;
                
                // Dot properties
                this.dots = [];
                this.dotRadius = 4;
                this.dotColor = '#ff0000';
                this.highlightedDotColor = '#ffaa00';
                this.nextDotId = 1;
                this.hoveredDotId = null;
                this.dotsList = document.getElementById('dotsList');
                
                this.setupCanvas();
                this.setupEventListeners();
            }
            
            setupCanvas() {
                // Set canvas size to match container
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const rect = this.container.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.redraw();
            }
            
            setupEventListeners() {
                // File input
                document.getElementById('imageInput').addEventListener('change', (e) => {
                    this.loadImage(e.target.files[0]);
                });
                
                // Reset button
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetView();
                });
                
                // Clear all dots button
                document.getElementById('clearDotsBtn').addEventListener('click', () => {
                    this.clearAllDots();
                });
                
                // Save button
                document.getElementById('saveBtn').addEventListener('click', () => {
                    this.saveData();
                });
                
                // Timestamp buttons
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.setStartTime();
                });
                
                document.getElementById('endBtn').addEventListener('click', () => {
                    this.setEndTime();
                });
                
                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.clearTimestamps();
                });
                
                // Timestamp input change listeners
                document.getElementById('startTime').addEventListener('input', (e) => {
                    this.startDateTime = e.target.value;
                });
                
                document.getElementById('endTime').addEventListener('input', (e) => {
                    this.endDateTime = e.target.value;
                });
                
                // BLE IDs input change listener
                document.getElementById('bleIdsInput').addEventListener('input', (e) => {
                    const input = e.target.value.trim();
                    if (input) {
                        this.allowedBleIds = input.split(',').map(id => id.trim()).filter(id => id.length > 0);
                    } else {
                        this.allowedBleIds = [];
                    }
                    this.updateDotsList(); // Refresh the list to update validation styling
                });
                
                // Floor number input change listener
                document.getElementById('floorNumberInput').addEventListener('input', (e) => {
                    const value = e.target.value.trim();
                    this.floorNumber = value ? parseInt(value, 10) : null;
                });
                
                // Mouse events for panning
                this.canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // Left mouse button for panning
                        this.startDrag(e);
                    }
                });
                this.canvas.addEventListener('mousemove', (e) => {
                    this.drag(e);
                    this.handleMouseMove(e);
                });
                this.canvas.addEventListener('mouseup', () => this.endDrag());
                this.canvas.addEventListener('mouseleave', () => {
                    this.endDrag();
                    this.clearDotHighlight();
                });
                
                // Right-click for dot placement
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    this.placeDot(e);
                });
                
                // Mouse wheel for zooming
                this.canvas.addEventListener('wheel', (e) => this.zoom(e));
                
                // Touch events for mobile support
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
                this.canvas.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));
            }
            
            loadImage(file) {
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.image = img;
                        this.resetView();
                        this.showCanvas();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
            
            showCanvas() {
                this.container.classList.remove('no-image');
                this.placeholder.style.display = 'none';
                this.canvas.style.display = 'block';
                this.zoomInfo.style.display = 'block';
            }
            
            resetView() {
                if (!this.image) return;
                
                // Calculate scale to fit image in canvas
                const scaleX = this.canvas.width / this.image.width;
                const scaleY = this.canvas.height / this.image.height;
                this.scale = Math.min(scaleX, scaleY, 1); // Don't scale up beyond 100%
                
                // Store the fit scale and use it as minimum
                this.fitScale = this.scale;
                this.minScale = Math.min(0.1, this.fitScale); // Allow zooming out to at least the fit scale
                
                // Center the image
                this.panX = (this.canvas.width - this.image.width * this.scale) / 2;
                this.panY = (this.canvas.height - this.image.height * this.scale) / 2;
                
                this.redraw();
            }
            
            setStartTime() {
                this.startDateTime = new Date().toISOString();
                const startInput = document.getElementById('startTime');
                startInput.value = this.startDateTime;
                startInput.disabled = false;
                // Enable end button after start is set
                document.getElementById('endBtn').disabled = false;
            }
            
            setEndTime() {
                this.endDateTime = new Date().toISOString();
                const endInput = document.getElementById('endTime');
                endInput.value = this.endDateTime;
                endInput.disabled = false;
                // Disable start button after end is set
                document.getElementById('startBtn').disabled = true;
            }
            
            clearTimestamps() {
                this.startDateTime = null;
                this.endDateTime = null;
                const startInput = document.getElementById('startTime');
                const endInput = document.getElementById('endTime');
                startInput.value = '';
                endInput.value = '';
                startInput.disabled = true;
                endInput.disabled = true;
                // Reset button states
                document.getElementById('startBtn').disabled = false;
                document.getElementById('endBtn').disabled = true;
            }
            
            clearAllDots() {
                this.dots = [];
                this.nextDotId = 1;
                this.hoveredDotId = null;
                this.updateDotsList();
                this.redraw();
            }
            
            async saveData() {
                if (!this.image) {
                    alert('Error: No image loaded.');
                    return;
                }
                
                if (!this.startDateTime || !this.endDateTime) {
                    alert('Error: Please set both start and end times before saving.');
                    return;
                }
                
                if (this.floorNumber === null || isNaN(this.floorNumber)) {
                    alert('Error: Please enter a floor number before saving.');
                    return;
                }
                
                // Check if start datetime is later than end datetime
                const startDate = new Date(this.startDateTime);
                const endDate = new Date(this.endDateTime);
                if (startDate >= endDate) {
                    alert('Error: Start datetime must be earlier than end datetime.');
                    return;
                }
                
                if (this.dots.length === 0) {
                    alert('Error: No dots have been placed.');
                    return;
                }
                
                // Prepare data object
                const data = {
                    start_datetime: this.startDateTime,
                    end_datetime: this.endDateTime,
                    dots: this.dots.map(dot => ({
                        ble_tx_id: dot.dotId || '',
                        coordinate_pixels: [dot.imageX, dot.imageY],
                        datetime: dot.timestamp,
                        floor: this.floorNumber
                    }))
                };
                
                // Generate filename based on timestamps
                const formatTimestamp = (isoString) => {
                    return isoString.replace(/[-:]/g, '').replace(/\.\d{3}/, '');
                };
                
                const baseFilename = `${formatTimestamp(this.startDateTime)}_to_${formatTimestamp(this.endDateTime)}`;
                
                // Dynamically load JSZip
                if (typeof JSZip === 'undefined') {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                    document.head.appendChild(script);
                    await new Promise((resolve, reject) => {
                        script.onload = resolve;
                        script.onerror = reject;
                    });
                }
                
                const zip = new JSZip();
                
                // 1. Add JSON data
                const jsonString = JSON.stringify(data, null, 2);
                zip.file(`${baseFilename}.json`, jsonString);
                
                // 2. Add original image
                const originalImageBlob = await this.getOriginalImageBlob();
                zip.file(`${baseFilename}.jpg`, originalImageBlob);
                
                // 3. Add image with dots overlay
                const imageWithDotsBlob = await this.createImageWithDots();
                zip.file(`${baseFilename}_with_dots.jpg`, imageWithDotsBlob);
                
                // Generate and download zip
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(zipBlob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `${baseFilename}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            async getOriginalImageBlob() {
                return new Promise((resolve, reject) => {
                    const canvas = document.createElement('canvas');
                    canvas.width = this.image.width;
                    canvas.height = this.image.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(this.image, 0, 0);
                    canvas.toBlob((blob) => {
                        if (blob) resolve(blob);
                        else reject(new Error('Failed to create image blob'));
                    }, 'image/jpeg', 0.95);
                });
            }
            
            async createImageWithDots() {
                return new Promise((resolve, reject) => {
                    const canvas = document.createElement('canvas');
                    canvas.width = this.image.width;
                    canvas.height = this.image.height;
                    const ctx = canvas.getContext('2d');
                    
                    // Draw the original image
                    ctx.drawImage(this.image, 0, 0);
                    
                    // Draw all dots at their original image coordinates with much larger radius
                    const exportDotRadius = 30; // Much larger radius for export visibility
                    this.dots.forEach(dot => {
                        ctx.beginPath();
                        ctx.arc(dot.imageX, dot.imageY, exportDotRadius, 0, 2 * Math.PI);
                        ctx.fillStyle = this.dotColor;
                        ctx.fill();
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 8;
                        ctx.stroke();
                    });
                    
                    canvas.toBlob((blob) => {
                        if (blob) resolve(blob);
                        else reject(new Error('Failed to create image with dots blob'));
                    }, 'image/jpeg', 0.95);
                });
            }
            
            placeDot(e) {
                if (!this.image || this.isDragging) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                
                // Convert canvas coordinates to image coordinates
                const imageX = (canvasX - this.panX) / this.scale;
                const imageY = (canvasY - this.panY) / this.scale;
                
                // Check if the click is within the image bounds
                if (imageX >= 0 && imageX < this.image.width && imageY >= 0 && imageY < this.image.height) {
                    const dot = {
                        id: this.nextDotId++,
                        imageX: imageX,
                        imageY: imageY,
                        canvasX: canvasX,
                        canvasY: canvasY,
                        dotId: '',
                        timestamp: new Date().toISOString()
                    };
                    
                    this.dots.push(dot);
                    this.updateDotsList();
                    this.redraw();
                }
            }
            
            updateDotId(dotId, value) {
                const dot = this.dots.find(d => d.id === dotId);
                if (dot) {
                    dot.dotId = value;
                }
            }
            
            deleteDot(dotId) {
                this.dots = this.dots.filter(dot => dot.id !== dotId);
                this.updateDotsList();
                this.redraw();
            }
            
            updateDotsList() {
                if (this.dots.length === 0) {
                    this.dotsList.innerHTML = '<p class="no-dots-message">Right-click on the image to place dots</p>';
                    return;
                }
                
                let html = '';
                this.dots.forEach((dot, index) => {
                    // Determine validation class
                    let validationClass = '';
                    if (this.allowedBleIds.length > 0 && dot.dotId) {
                        validationClass = this.allowedBleIds.includes(dot.dotId) ? 'valid' : 'invalid';
                    }
                    
                    html += `
                        <div class="dot-item" data-dot-id="${dot.id}"
                             onmouseenter="viewer.highlightDot(${dot.id})"
                             onmouseleave="viewer.clearDotHighlight()">
                            <button class="dot-delete-btn" onclick="viewer.deleteDot(${dot.id})">×</button>
                            <div class="dot-coordinates">X: ${dot.imageX.toFixed(2)}, Y: ${dot.imageY.toFixed(2)}</div>
                            <div class="dot-timestamp">${dot.timestamp}</div>
                            <input type="text" class="dot-id-input ${validationClass}" placeholder="Enter ID..."
                                   value="${dot.dotId}"
                                   oninput="viewer.updateDotId(${dot.id}, this.value)"
                                   onblur="viewer.updateDotsList()">
                        </div>
                    `;
                });
                
                this.dotsList.innerHTML = html;
            }
            
            handleMouseMove(e) {
                if (!this.image || this.isDragging) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                let hoveredDot = null;
                for (let dot of this.dots) {
                    const screenX = dot.imageX * this.scale + this.panX;
                    const screenY = dot.imageY * this.scale + this.panY;
                    const distance = Math.sqrt(Math.pow(mouseX - screenX, 2) + Math.pow(mouseY - screenY, 2));
                    
                    if (distance <= this.dotRadius + 5) {
                        hoveredDot = dot;
                        break;
                    }
                }
                
                if (hoveredDot && hoveredDot.id !== this.hoveredDotId) {
                    this.hoveredDotId = hoveredDot.id;
                    this.highlightTile(hoveredDot.id);
                    this.redraw();
                } else if (!hoveredDot && this.hoveredDotId) {
                    this.clearDotHighlight();
                }
            }
            
            highlightTile(dotId) {
                document.querySelectorAll('.dot-item.highlighted').forEach(item => {
                    item.classList.remove('highlighted');
                });
                
                const tile = document.querySelector(`[data-dot-id="${dotId}"]`);
                if (tile) {
                    tile.classList.add('highlighted');
                    // Scroll the tile into view if it's not visible
                    tile.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
            
            highlightDot(dotId) {
                this.hoveredDotId = dotId;
                this.redraw();
            }
            
            clearDotHighlight() {
                this.hoveredDotId = null;
                document.querySelectorAll('.dot-item.highlighted').forEach(item => {
                    item.classList.remove('highlighted');
                });
                this.redraw();
            }
            
            startDrag(e) {
                if (!this.image) return;
                
                this.isDragging = true;
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
                this.container.style.cursor = 'grabbing';
            }
            
            drag(e) {
                if (!this.isDragging || !this.image) return;
                
                const deltaX = e.clientX - this.lastMouseX;
                const deltaY = e.clientY - this.lastMouseY;
                
                this.panX += deltaX;
                this.panY += deltaY;
                
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
                
                this.redraw();
            }
            
            endDrag() {
                this.isDragging = false;
                this.container.style.cursor = 'grab';
            }
            
            zoom(e) {
                if (!this.image) return;
                
                e.preventDefault();
                
                // Get mouse position relative to canvas
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Calculate zoom
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(this.minScale, Math.min(this.maxScale, this.scale * zoomFactor));
                
                if (newScale !== this.scale) {
                    // Zoom towards mouse position
                    const scaleChange = newScale / this.scale;
                    this.panX = mouseX - (mouseX - this.panX) * scaleChange;
                    this.panY = mouseY - (mouseY - this.panY) * scaleChange;
                    this.scale = newScale;
                    
                    this.redraw();
                }
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                
                if (!this.image) return;
                
                this.isTouching = true;
                this.touches = Array.from(e.touches);
                this.touchStartTime = Date.now();
                this.hasPerformedGesture = false;
                
                if (this.touches.length === 1) {
                    // Single touch - potentially start panning
                    const touch = this.touches[0];
                    this.isDragging = false;
                    this.lastMouseX = touch.clientX;
                    this.lastMouseY = touch.clientY;
                    this.touchStartPos = { x: touch.clientX, y: touch.clientY };
                } else if (this.touches.length === 2) {
                    // Two touches - prepare for pinch zoom
                    this.isDragging = false;
                    this.hasPerformedGesture = true;
                    const touch1 = this.touches[0];
                    const touch2 = this.touches[1];
                    this.lastTouchDistance = this.getTouchDistance(touch1, touch2);
                }
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                
                if (!this.image || !this.isTouching) return;
                
                this.touches = Array.from(e.touches);
                
                if (this.touches.length === 1) {
                    // Single touch - check if we should start panning
                    const touch = this.touches[0];
                    
                    // Calculate movement from initial touch position
                    if (this.touchStartPos) {
                        const moveDistance = this.getTouchDistance(
                            { clientX: touch.clientX, clientY: touch.clientY },
                            { clientX: this.touchStartPos.x, clientY: this.touchStartPos.y }
                        );
                        
                        // If moved more than 10px, consider it a pan gesture
                        if (moveDistance > 10) {
                            this.isDragging = true;
                            this.hasPerformedGesture = true;
                        }
                    }
                    
                    if (this.isDragging) {
                        // Single touch panning
                        const deltaX = touch.clientX - this.lastMouseX;
                        const deltaY = touch.clientY - this.lastMouseY;
                        
                        this.panX += deltaX;
                        this.panY += deltaY;
                        
                        this.lastMouseX = touch.clientX;
                        this.lastMouseY = touch.clientY;
                        
                        this.redraw();
                    }
                } else if (this.touches.length === 2) {
                    // Pinch zoom
                    this.hasPerformedGesture = true;
                    const touch1 = this.touches[0];
                    const touch2 = this.touches[1];
                    const currentDistance = this.getTouchDistance(touch1, touch2);
                    
                    if (this.lastTouchDistance > 0) {
                        const rect = this.canvas.getBoundingClientRect();
                        
                        // Get center point between the two touches
                        const centerX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
                        const centerY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
                        
                        // Calculate zoom factor based on distance change
                        const zoomFactor = currentDistance / this.lastTouchDistance;
                        const newScale = Math.max(this.minScale, Math.min(this.maxScale, this.scale * zoomFactor));
                        
                        if (newScale !== this.scale) {
                            // Zoom towards center point
                            const scaleChange = newScale / this.scale;
                            this.panX = centerX - (centerX - this.panX) * scaleChange;
                            this.panY = centerY - (centerY - this.panY) * scaleChange;
                            this.scale = newScale;
                            
                            this.redraw();
                        }
                    }
                    
                    this.lastTouchDistance = currentDistance;
                }
            }
            
            handleTouchEnd(e) {
                e.preventDefault();
                
                const remainingTouches = Array.from(e.touches);
                
                // Reset touch state
                this.isTouching = remainingTouches.length > 0;
                this.isDragging = false;
                this.touches = remainingTouches;
                this.touchStartPos = null;
                this.hasPerformedGesture = false;
                
                if (remainingTouches.length === 0) {
                    this.lastTouchDistance = 0;
                }
            }
            
            getTouchDistance(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            redraw() {
                if (!this.image) return;
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw image
                this.ctx.save();
                this.ctx.translate(this.panX, this.panY);
                this.ctx.scale(this.scale, this.scale);
                this.ctx.drawImage(this.image, 0, 0);
                this.ctx.restore();
                
                // Draw dots
                this.ctx.save();
                this.dots.forEach(dot => {
                    const screenX = dot.imageX * this.scale + this.panX;
                    const screenY = dot.imageY * this.scale + this.panY;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(screenX, screenY, this.dotRadius, 0, 2 * Math.PI);
                    this.ctx.fillStyle = dot.id === this.hoveredDotId ? this.highlightedDotColor : this.dotColor;
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });
                this.ctx.restore();
                
                // Update zoom info
                this.zoomInfo.textContent = `Zoom: ${Math.round(this.scale * 100)}%`;
            }
        }
        
        // Initialize the viewer when the page loads
        let viewer; // Global reference for inline event handlers
        document.addEventListener('DOMContentLoaded', () => {
            viewer = new ImageViewer();
        });
    </script>
</body>
</html>